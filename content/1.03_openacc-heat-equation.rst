.. _openacc-heat-equation:

Introduction to OpenACC (cont.)
================================

 .. image:: img/development-cycle.png

- *Analyze* your code to determine most likely places needing parallelization or optimization.

- *Parallelize* your code by starting with the most time consuming parts and check for correctness.

- *Optimize* your code to improve observed speed-up from parallelization.

-  The four key steps in porting to high performance accelerated code:

   1. Analyze/Identify parallelism
   2. Express parallelism
   3. Express data movement
   4. Optimize data movement/loop performance
   5. Go back to 1!

.. - One should generally start the process at the top with the analyze step. For complex applications, it's useful to have a profiling tool available to learn where your application is spending its execution time and to focus your efforts there.  Since our example code is quite a bit simpler than a full application, we'll skip profiling the code and simply analyze the code by reading it

Otimizing data movement
-----------------------

-  Constructs and clauses for

   -  defining the variables on the device
   -  transferring data to/from the device

-  All variables used inside the ``parallel`` or ``kernels`` region will
   be treated as *implicit* variables if they are not present in any
   data clauses, i.e. copying to and from to the device is automatically
   performed

 .. code :: c
    /* #pragma acc data copy(vecA,vecB,vecC)
    #pragma acc kernels
    for (i = 0; i < NX; i++) {
        vecC[i] = vecA[i] * vecB[i];
    }        

 .. code :: bash

    $ pgcc -g -O3 -acc -Minfo=accel -ta=nvidia sum.c -o sum
    23, Generating implicit copyout(vecC[:]) [if not already present]
        Generating implicit copyin(vecB[:],vecA[:]) [if not already present]
   
    $ export PGI_ACC_TIME=1
    $ ./sum
    time(us): 247
    23: data region reached 2 times
        23: data copyin transfers: 2
             device time(us): total=174 max=99 min=75 avg=87
        25: data copyout transfers: 1
             device time(us): total=73 max=73 min=73 avg=73
  
    #### previous with explicit data copy
      Accelerator Kernel Timing data
       main  NVIDIA  devicenum=0
    time(us): 451
    21: data region reached 2 times
        21: data copyin transfers: 3
             device time(us): total=245 max=100 min=71 avg=81
        29: data copyout transfers: 3
             device time(us): total=206 max=72 min=67 avg=68


-  Typically data on the device has the same lifetime as the OpenACC
   construct (``parallel``, ``kernels``, ``data``) it is declared in

-  It is possible to declare and refer to data residing statically on
   the device until deallocation takes place


.. typealong:: Adding two vector

   .. tabs::

      .. tab:: cpu

         .. literalinclude:: ../examples/OpenACC/HeatEquation/c/heat_equation.c
                                    :language: c

      .. tab:: OpenACC parallel loop

         .. literalinclude:: ../examples/OpenACC/HeatEquation/solution/c/heat_equation_openacc_1.c
                                    :language: c

      .. tab:: OpenACC loop collapse

         .. literalinclude:: ../examples/OpenACC/HeatEquation/solution/c/heat_equation_openacc_2.c
                                    :language: c

      .. tab:: OpenACC data create

         .. literalinclude:: ../examples/OpenACC/HeatEquation/solution/c/heat_equation_openacc_data_1.c
                                                :language: c

Data construct: example
-----------------------

Data constructs: data clauses
-----------------------------

   ``present(var-list)`` 

   - **on entry/exit:** assume that memory is allocated and that data is present on the device

   ``create(var-list)``

   -  **on entry:** allocate memory on the device, unless it was already
      present
   -  **on exit:** deallocate memory on the device, if it was allocated
      on entry

``copy(var-list)``

-  **on entry:** if data is present on the device on entry, behave as
   with the ``present`` clause, otherwise allocate memory on the device
   and copy data from the host to the device.
-  **on exit:** copy data from the device to the host and deallocate
   memory on the device if it was allocated on entry

   ``copyin(var-list)``

   -  **on entry:** same as ``copy`` on entry
   -  **on exit:** deallocate memory on the device if it was allocated
      on entry

  ``copyout(var-list)``

   -  **on entry:** if data is present on the device on entry, behave as
      with the ``present`` clause, otherwise allocate memory on the
      device
   -  **on exit:** same as ``copy`` on exit


``reduction(operator:var-list)``

- the operator can be ``+,-,*,max,min``
-  Performs reduction on the (scalar) variables in list
-  Private reduction variable is created for each gangâ€™s partial result

   -  initialised to operators initial value

-  After parallel region the reduction operation is applied to the
   private variables and the result is aggregated to the shared variable
   *and* the aggregated result is combined with the original value of
   the variable


Data specification
^^^^^^^^^^^^^^^^^^

-  Data clauses specify functionality for different variables
-  Overlapping data specifications are not allowed
-  For array data, *array ranges* can be specified

   -  C/C++: ``arr[start_index:length]``, for instance ``vec[0:n]``
   -  Fortran: ``arr(start_index:end_index)``, for instance ``vec(1:n)``

-  Note: array data **must** be *contiguous* in memory (vectors,
   multidimensional arrays etc.)

Default data environment in compute constructs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

-  All variables used inside the ``parallel`` or ``kernels`` region will
   be treated as *implicit* variables if they are not present in any
   data clauses, i.e. copying to and from the device is automatically
   performed
-  Implicit *array* variables are treated as having the ``copy`` clause
   in both cases
-  Implicit *scalar* variables are treated as having the

   -  ``copy`` clause in ``kernels``
   -  ``firstprivate`` clause in ``parallel``

``data`` construct: example
---------------------------


Unstructured data regions
^^^^^^^^^^^^^^^^^^^^^^^^^

-  Unstructured data regions enable one to handle cases where allocation
   and freeing is done in a different scope
-  Useful for e.g. C++ classes, Fortran modules
-  ``enter data`` defines the start of an unstructured data region

   -  C/C++: ``#pragma acc enter data [clauses]``
   -  Fortran: ``!$acc enter data [clauses]``

-  ``exit data`` defines the end of an unstructured data region

   -  C/C++: ``#pragma acc exit data [clauses]``
   -  Fortran: ``!$acc exit data [clauses]``

Unstructured data
^^^^^^^^^^^^^^^^

.. code:: c

   class Vector {
       Vector(int n) : len(n) {
           v = new double[len];
           #pragma acc enter data create(v[0:len])
       }
       ~Vector() {
           #pragma acc exit data delete(v[0:len])
           delete[] v;
       }
       double v;
       int len;
   };

Enter data clauses
^^^^^^^^^^^^^^^^^^

   ``if(condition)``
 
   -  Do nothing if condition is false

   ``create(var-list)``

   -  Allocate memory on the device

   ``copyin(var-list)``

   -  Allocate memory on the device and copy data from the host to the
      device

Exit data clauses
^^^^^^^^^^^^^^^^^

   ``if(condition)``

   -  Do nothing if condition is false

   ``delete(var-list)``

   -  Deallocate memory on the device


.. container:: column

   ``copyout(var-list)``

   -  Deallocate memory on the device and copy data from the device to
      the host

   -  in-depth: *dynamic* reference count decremented, and
       deallocation happens if both reference counts (*dynamic* and
       *structured*) are zero

Data directive: update
^^^^^^^^^^^^^^^^^^^^^^

-  Define variables to be updated within a data region between host and
   device memory

   -  C/C++: ``#pragma acc update [clauses]``
   -  Fortran: ``!$acc update [clauses]``

-  Data transfer direction controlled by ``host(var-list)`` or
   ``device(var-list)`` clauses

   -  ``self`` (``host``) clause updates variables from device to host
   -  ``device`` clause updates variables from host to device

-  At least one data direction clause must be present

.. _data-directive-update-1:

Data directive: update
^^^^^^^^^^^^^^^^^^^^^^

-  ``update`` is a single line executable directive
-  Useful for producing snapshots of the device variables on the host or
   for updating variables on the device

   -  Pass variables to host for visualization
   -  Communication with other devices on other computing nodes

-  Often used in conjunction with

   -  Asynchronous execution of OpenACC constructs
   -  Unstructured data regions

``update`` directive: example
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. container:: column

Data directive: declare
^^^^^^^^^^^^^^^^^^^^^^^

-  Makes a variable resident in accelerator memory
-  Added at the declaration of a variable
-  Data life-time on device is the implicit life-time of the variable

   -  C/C++: ``#pragma acc declare [clauses]``
   -  Fortran: ``!$acc declare [clauses]``

-  Supports usual data clauses, and additionally

   -  ``device_resident``
   -  ``link``

Porting and managed memory
^^^^^^^^^^^^^^^^^^^^^^^^^^

.. container:: column

   -  Porting a code with complicated data structures can be challenging
      because every field in type has to be copied explicitly
   -  Recent GPUs have *Unified Memory* and support for page faults

.. container:: column

   .. code:: c

      typedef struct points {
          double x, y;
          int n;
      }

      void init_point() {
          points p;

          #pragma acc data create(p)
          {
              p.size = n;
              p.x = (double)malloc(...
              p.y = (double)malloc(...
              #pragma acc update device(p)
              #pragma acc copyin (p.x[0:n]...

Managed memory
^^^^^^^^^^^^^^

-  Managed memory copies can be enabled on PGI compilers

   -  Pascal (P100): ``--ta=tesla,cc60,managed``
   -  Volta (V100): ``--ta=tesla,cc70,managed``

-  For full benefits Pascal or Volta generation GPU is needed
-  Performance depends on the memory access patterns

   -  For some cases performance is comparable with explicitly tuned
      versions




Summary
-------

-  Data directive

   -  Structured data region
   -  Clauses: ``copy``, ``present``, ``copyin``, ``copyout``,
      ``create``

-  Enter data & exit data

   -  Unstructured data region

-  Update directive
-  Declare directive

